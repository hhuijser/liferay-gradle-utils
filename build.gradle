import com.liferay.portal.kernel.util.UnicodeProperties

import java.text.SimpleDateFormat

import java.util.concurrent.ConcurrentHashMap
import java.util.regex.Pattern
import java.util.jar.JarFile
import java.util.zip.ZipFile

import groovy.io.FileType
import groovy.io.FileVisitResult

import groovy.json.JsonSlurper

import groovyx.gpars.GParsPool

import org.apache.commons.codec.digest.DigestUtils
import org.apache.commons.lang3.StringUtils
import org.apache.commons.lang3.time.FastDateFormat
import org.apache.commons.text.WordUtils

buildscript {
	dependencies {
		classpath "com.liferay.portal:com.liferay.portal.kernel:latest.release"
		classpath "commons-codec:commons-codec:1.10"
		classpath "org.apache.commons:commons-lang3:3.6"
		classpath "org.apache.commons:commons-text:1.1"
		classpath "org.codehaus.gpars:gpars:1.2.1"
	}

	repositories {
		mavenLocal()

		mavenCentral()
	}
}

plugins {
	id "de.undercouch.download" version "3.1.1"
}

defaultTasks "copyLibsToCache"

ext {
	portalDir = new File("S:/lr/liferay-portal")
	portal62Dir = new File("S:/lr/liferay-portal-6.2.x")

	gradleCacheDir = new File(portalDir, ".gradle/caches/modules-2/files-2.1")
	modulesDir = new File(portalDir, "modules")
}

repositories {
	mavenLocal()

	mavenCentral()
}

task addImportPackages
task addPortalBuild
task addSeparateReposGradleProperties
task addStaticBuild
task checkBndInclude
task checkBndInstructions
task checkBndServiceInstructions
task checkBrokenJarsKernel
task checkCache
task checkEmptyPackages
task checkImplicitPortlets
task checkJenkins
task checkKeywords
task checkLongSQL
task checkPackageJson
task checkPortlets
task consolidateLang
task checkLanguages
task copyLibToCache
task copyLibsToCache
task checkMPBnd
task copyRemoteLibToCache
task checkResources
task deleteBuildXml(type: Delete)
task deleteIvyXml(type: Delete)
task deletePackageInfo
task deletePortalBuild(type: Delete)
task diffArtifact
task dumpSnapshotVersions
task findClass
task fixBnd
task fixCache
task fixChangelogs
task fixMarkerFiles
task fixPackageInfo
task fixPluginTags
task fixProjectTemplatesVelocity
task fixRelengIgnoreVersions
task fixSeparateRepoDeps
task fixShrinkwrap
task fixTestClasspaths
task fixWrongPrepNext
task initApps
task initPortalBuild
task initSeparateRepos
task initSeparateReposGit
task initTestIntegration
task moveLPS64532
task moveModules
task moveStatic
task printExtensions
task printPluginChangelog
task removeGitIgnore
task removeLanguageAutomaticLabels
task removeOldSubrepos
task removeSnapshots
task removeTouch
task renameBuildFiles
task replaceBuildCIPortalFiles
task replaceBuildXml
task replaceProjectDeps
task wrapper(type: Wrapper)
task writeDependencyVersions
task writeGradleTestsScript
task writeSettingsIncludes

addImportPackages << {
	assert project.properties["dirName"] : "Please provide -PdirName"

	def modulesRootDir = new File(portalDir.parentFile, dirName)

	assert modulesRootDir.exists()

	def bndBndFileTree = fileTree(dir: modulesRootDir, excludes: ["**/bin/", "**/build/", "**/classes/", "**/node_modules/", "**/*-test/"], include: "*/**/bnd.bnd")

	def importPackages = '''
Import-Package:\\
	com.liferay.portal.kernel.dao.search;version="[7.2.0,8.0.0)",\\
	com.liferay.portal.kernel.search;version="[7.5.0,8.0.0)",\\
	\\
	*
'''

	bndBndFileTree.each {
		def buildGradleFile = new File(it.parentFile, "build.gradle")

		if (!buildGradleFile.text.contains("com.liferay.portal.kernel")) {
			return
		}

		def bndBnd = it.getText("UTF-8")

		if (bndBnd.contains("Import-Package")) {
			println "WARNING: ${it} contains already an 'Import-Package' header!"
		}

		bndBnd += importPackages

		it.setText bndBnd, "UTF-8"
	}
}

addPortalBuild << {
	assert project.properties["dirName"] : "Please provide -PdirName"

	def modulesRootDir = new File(portalDir.parentFile, dirName)

	assert modulesRootDir.exists()

	def moduleFileTree = fileTree(dir: modulesRootDir, excludes: ["**/bin/", "**/build/", "**/classes/", "**/node_modules/", "**/*-test/"], includes: ["*/**/bnd.bnd", "*/**/gulpfile.js"])

	moduleFileTree.each {
		def moduleDir = it.parentFile

		def lfrbuildPortalFile = new File(it.parentFile, ".lfrbuild-portal")

		if (!lfrbuildPortalFile.exists()) {
			lfrbuildPortalFile.createNewFile()

			println "Added ${lfrbuildPortalFile}"
		}
	}
}

addSeparateReposGradleProperties << {
	def lines = project.properties["lines"].tokenize(",")

	def gitRepoFileTree = fileTree(dir: modulesDir, include: "**/.gitrepo")

	def excludeReadOnly = Boolean.getBoolean("exclude.read.only")

	gitRepoFileTree.each {
		gitRepoFile ->

		if (excludeReadOnly && gitRepoFile.text.contains("mode = pull")) {
			return
		}

		def gradlePropertiesFile = new File(gitRepoFile.parentFile, "gradle.properties")

		def gradleProperties = gradlePropertiesFile.readLines()

		gradlePropertiesFile.text = (gradleProperties + lines).toSorted().join(System.lineSeparator())
	}
}

addStaticBuild << {
	def bndFiles = fileTree(dir: modulesDir, include: "**/bnd.bnd")

	def staticDeployDir = 'liferay {\n\tdeployDir = file("${liferayHome}/osgi/static")\n}'

	bndFiles.each {
		def dir = it.parentFile

		def staticBuildFile = new File(dir, "static.build")

		if (staticBuildFile.exists()) {
			return
		}

		def buildGradleFile = new File(dir, "build.gradle")

		if (!buildGradleFile.exists()) {
			return
		}

		def buildGradle = buildGradleFile.text

		buildGradle = buildGradle.replace('\r', '')

		if (!buildGradle.contains(staticDeployDir)) {
			return
		}

		def created = staticBuildFile.createNewFile()

		if (created) {
			println "Created " + staticBuildFile
		}
		else {
			throw new GradleException("Unable to create " + staticBuildFile)
		}

		buildGradleFile.text = buildGradle.replace(staticDeployDir, '')
	}
}

checkBndInclude << {
	def bndFiles = fileTree(dir: modulesDir, include: "**/bnd.bnd")

	bndFiles.each {
		File bndFile ->

		Properties bndProperties = new Properties()

		bndFile.withInputStream {
			bndProperties.load it
		}

		String include = bndProperties["-include"]

		if (include) {
			def includeList = include.tokenize(",")

			def dir = bndFile.parentFile

			includeList.each {
				def includedFile = new File(dir, it)

				if (!includedFile.exists()) {
					throw new GradleException("${includedFile.canonicalPath} is included in ${bndFile} but it does not exist")
				}
			}

			println include
		}
	}
}

checkBndInstructions << {
	def bndInstructions = new TreeSet<String>()

	def bndFiles = fileTree(dir: modulesDir, include: "**/bnd.bnd")

	bndFiles.each {
		bndFile ->

		def bndProperties = new Properties()

		bndFile.withInputStream {
			bndProperties.load it
		}

		bndInstructions.addAll(bndProperties.stringPropertyNames())
	}

	bndInstructions.each {
		println it
	}
}

checkBndServiceInstructions << {
	def bndFiles = fileTree(dir: modulesDir, include: "**/bnd.bnd")

	def expectedProperties = [:]

	expectedProperties["-liferay-spring-dependency"] = 'com.liferay.portal.spring.extender.service.ServiceReference'
	expectedProperties["Liferay-Spring-Context"] = 'META-INF/spring'
	expectedProperties["Require-Capability"] = 'liferay.extender;filter:="(&(liferay.extender=spring.extender)(version>=1.0)(!(version>=2.0)))"'

	bndFiles.each {
		bndFile ->

		def bndProperties = new Properties()

		bndFile.withInputStream {
			bndProperties.load it
		}

		if (!bndProperties["Liferay-Service"]) {
			return
		}

		def dir = bndFile.parentFile

		def buildGradleFile = new File(dir, "build.gradle")

		if (!buildGradleFile.text.contains("com.liferay.portal.spring.extender")) {
			throw new GradleException("Unable to find 'com.liferay.portal.spring.extender' in ${buildGradleFile}")
		}

		expectedProperties.each {
			k, v ->

			if (bndProperties[k] != v) {
				throw new GradleException("Unable to find ${k}=${v} in ${bndFile}")
			}
		}

		println "Checked ${dir}"
	}
}

checkBrokenJarsKernel << {
	def jarFileTree = fileTree(dir: gradleCacheDir, include: "com.liferay/**/*.jar")

	jarFileTree.each {
		jarFile ->

		def zipFile = new ZipFile(jarFile)

		zipFile.entries().each {
			zipEntry ->

			if (zipEntry.directory && zipEntry.name.endsWith("/kernel/")) {
				println jarFile
			}
		}
	}
}

checkCache << {
	gradleCacheDir.eachFileRecurse(FileType.FILES) {
		File file ->

		String sha1 = _getSHA1(file)

		if (file.parentFile.name != sha1) {
			println "This file is in a directory with a wrong SHA1: " + file
		}
	}
}

checkMPBnd << {
	def appPackages = new HashMap<String, Set<String>>()

	def bndFileTree = fileTree(dir: new File(modulesDir, "../marketplace"), include: "*/bnd.bnd")

	bndFileTree.each {
		File bndFile ->

		def bndProperties = new Properties()

		bndFile.withInputStream {
			bndProperties.load it
		}

		def appsString = bndProperties["Liferay-Releng-Dependent-Apps"]

		def apps = appsString.tokenize(",")

		apps.each {
			app ->

			app = app.trim()

			def index = app.indexOf(":")

			app = app.substring(0, index)

			Set<String> packages = appPackages[app]

			if (packages == null) {
				packages = new HashSet<String>()

				appPackages[app] = packages
			}

			packages << bndFile.parentFile.name
		}
	}

	appPackages.each {
		app, packages ->

		if (packages.size() > 1) {
			println "${app} is in ${packages}"
		}
	}
}

checkEmptyPackages << {
	def bndFiles = fileTree(dir: modulesDir, exclude: "third-party/", include: "**/bnd.bnd")

	bndFiles.each {
		bndFile ->

		Properties bndProperties = new Properties()

		bndFile.withInputStream {
			bndProperties.load it
		}

		def exportPackage = bndProperties["Export-Package"]

		if (!exportPackage) {
			return
		}

		def moduleDir = bndFile.parentFile

		def exportedPackages = exportPackage.split(",")

		exportedPackages.each {
			if ((it.indexOf('*') != -1) || (it.indexOf(';') != -1)) {
				return
			}

			def packageFiles = fileTree(dir: moduleDir, exclude: "**/packageinfo", include: "src/main/*/" + it.replace('.' as char, '/' as char) + "/")

			if (packageFiles.empty) {
				println "Package ${it} in ${moduleDir} is both exported and empty"
			}
		}
	}
}

checkJenkins << {
	println "Checking \"${reportMatch}\" in ${reportUrl}..."

	def url = new URL(reportUrl)

	url.text.eachMatch(/"(https:\/\/[^"]+\/\/console)"/) {
		def consoleUrl = new URL(it[1] + "Text")

		if (consoleUrl.text.contains(reportMatch)) {
			println "\"${reportMatch}\" found in ${consoleUrl}"
		}
	}
}

checkKeywords << {
	if (!project.hasProperty("dir")) {
		throw new GradleException("Please pass -Pdir argument")
	}

	def keywordsFile = file("keywords.txt")

	def keywords = keywordsFile.readLines()

	def foundKeywords = new HashSet<String>()

	def fileTree = fileTree(dir: new File(modulesDir, dir))

	fileTree.each {
		def content = it.text

		keywords.each {
			if (content.contains(it)) {
				foundKeywords << it
			}
		}
	}

	println "Keywords not found: " + (keywords - foundKeywords)
}

checkImplicitPortlets << {
	def portletFileTree = fileTree(dir: modulesDir, exclude: "**/WEB-INF/", include: "**/apps/**/*Portlet.java")

	portletFileTree.each {
		if (it.text.contains("javax.portlet.name")) {
			return
		}

		println it
	}
}

checkLongSQL << {
	assert project.properties["sqlDir"] : "Please provide -PsqlDir"

	def tablesFileTree = fileTree(dir: sqlDir, include: "**/tables.sql")

	def pattern = /\t(\w{30}\w*) [A-Z]/

	tablesFileTree.each {
		tablesFile ->

		tablesFile.text.eachMatch(pattern) {
			all, colName ->

			println "Found long SQL column in ${tablesFile}: ${colName}"
		}
	}
}

checkPackageJson << {
	def packageJsonFileTree = fileTree(dir: modulesDir, excludes: ["**/archetype-resources/", "**/bin/", "**/build/", "**/classes/", "**/node_modules/"], include: "**/package.json")

	def jsonSlurper = new JsonSlurper()

	packageJsonFileTree.each {
		packageJsonFile ->

		def dir = packageJsonFile.parentFile

		def bndBndFile = new File(dir, "bnd.bnd")

		if (!bndBndFile.exists()) {
			return
		}

		def bndProperties = GUtil.loadProperties(bndBndFile)

		def packageJson = jsonSlurper.parse(packageJsonFile)

		assert dir.name == packageJson.name
		assert bndProperties.getProperty("Bundle-Version") == packageJson.version
	}
}

checkPortlets << {
	def portletFileTree = fileTree(dir: modulesDir, excludes: ["**/portal-monitoring/", "**/portal-osgi-web-portlet-container-test/", "**/portal-portlet-bridge-soy/"], include: "**/*Portlet.java")

	portletFileTree.each {
		def dir = it.parentFile

		while (true) {
			def bndBndFile = new File(dir, "bnd.bnd")

			if (bndBndFile.exists()) {
				break
			}

			dir = dir.parentFile
		}

		if (!dir.name.endsWith("-web")) {
			throw new GradleException("${dir.name} should ends with -web")
		}

		println "${dir.name} is okay"
	}
}

consolidateLang << {
	if (!project.hasProperty("langKeys")) {
		throw new GradleException("Please pass -PlangKeys argument")
	}

	if (!project.hasProperty("langFrom")) {
		throw new GradleException("Please pass -PlangFrom argument")
	}

	def langKeysList = langKeys.tokenize(",")

	def moduleDir = file(langFrom)

	if (!moduleDir.exists()) {
		moduleDir = _getModuleDir(langFrom)
	}

	if (moduleDir == null) {
		throw new GradleException("Unable to find ${langFrom} in ${modulesDir}")
	}

	def contentDir = new File(moduleDir, "src/main/resources/content")

	if (!contentDir.exists()) {
		contentDir = new File(moduleDir, "docroot/WEB-INF/src/content")

		if (!contentDir.exists()) {
			throw new GradleException("Unable to find ${contentDir}")
		}
	}

	def contentDestDir = new File(portalDir, "portal-impl/src/content")

	def langFileTree = fileTree(dir: contentDir, include: "Language*.properties")

	langFileTree.each {
		langFile ->

		def destLangFile = new File(contentDestDir, langFile.name)

		if (!destLangFile.exists()) {
			throw new GradleException("Unable to find " + destLangFile)
		}

		UnicodeProperties langProperties = new UnicodeProperties()

		langProperties.load langFile.getText("UTF-8")

		langKeysList.each {
			key ->

			def value = langProperties[key]

			if (!value) {
				println "Unable to find ${key} in ${langFile}"

				return
			}

			destLangFile.withWriterAppend("UTF-8") {
				it.write "\n${key}=${value}"
			}

			println "Copied ${key}=${value} from ${langFile} to ${destLangFile}"
		}
	}
}

checkLanguages << {
	assert project.properties["dir"] : "Please provide -Pdir"

	def languageFileTree = fileTree(dir: dir, include: "**/src/main/resources/content/Language.properties")

	def languageProperties = languageFileTree.files.inject(new Properties()) {
		accProperties, curFile ->

		curFile.withInputStream {
			accProperties.load(it)
		}

		accProperties
	}

	def resourceActionsFileTree = fileTree(dir: dir, include: "**/src/main/resources/resource-actions/default.xml")

	def alreadyTranslatedActionKeys = [
		"ACCESS_IN_CONTROL_PANEL",
		"ADD_PORTLET_DISPLAY_TEMPLATE",
		"ADD_TO_PAGE",
		"CONFIGURATION",
		"DELETE",
		"UPDATE",
		"PERMISSIONS",
		"VIEW"
	]

	resourceActionsFileTree.each {
		resourceActionsFile ->

		resourceActionsFile.text.eachMatch(/<action-key>(\w+)<\/action-key>/) {
			all, actionKey ->

			if (!alreadyTranslatedActionKeys.contains(actionKey) && !languageProperties.containsKey("action." + actionKey)) {
				println "The action key '${actionKey}' is not translated"
			}
		}
	}
}

copyLibToCache << {
	_copyLibToCache(project, gradleCacheDir, project.properties["libGroup"], project.properties["libName"], project.properties["libVersion"], project.properties["libClassifier"])
}

copyLibsToCache {
	doLast {
		File libsFile = file("libs.txt")

		libsFile.eachLine {
			String line ->

			if (line.startsWith("#")) {
				return
			}

			List<String> tokens = line.tokenize(":")

			String libGroup = null
			String libName = null
			String libVersion = null
			String libClassifier = null

			if (tokens.size() == 2) {
				libGroup = "com.liferay"
				libName = tokens[0]
				libVersion = tokens[1]
			}
			else {
				libGroup = tokens[0]
				libName = tokens[1]
				libVersion = tokens[2]

				if (tokens.size() == 4) {
					libClassifier = tokens[3]
				}
			}

			_copyLibToCache(project, gradleCacheDir, libGroup, libName, libVersion, libClassifier)
		}
	}

	finalizedBy {
		fixCache
	}
}

copyRemoteLibToCache << {
	if (!project.hasProperty("libGroup") || !project.hasProperty("libName") || !project.hasProperty("libVersion")) {
		throw new GradleException("libGroup, libName, and libVersion are required")
	}

	def dependency = dependencies.create group: libGroup, name: libName, version: libVersion

	def configuration = configurations.detachedConfiguration dependency

	configuration.resolve()
}

checkResources << {
	// def resourcesFileTree = fileTree(dir: modulesDir, excludes: ["**/packageinfo", "**/internal/"], include: "apps/web-experience/**/src/main/resources/com/")
	def resourcesFileTree = fileTree(dir: modulesDir, excludes: ["sdk/gradle-templates/", "**/src/*/java/**/*.java", "**/source_formatter.ignore"], include: "**/src/*/java/")

	resourcesFileTree.each {
		println it
	}
}

deleteBuildXml {
	delete fileTree(dir: modulesDir, exclude: "**/samples/", include: "*/**/build.xml")
}

deleteIvyXml {
	delete fileTree(dir: modulesDir, include: "**/ivy.xml")
}

deletePackageInfo << {
	def bndFiles = fileTree(dir: modulesDir, include: "**/bnd.bnd")

	bndFiles.each {
		bndFile ->

		def moduleDir = bndFile.parentFile

		Properties bndProperties = new Properties()

		bndFile.withInputStream {
			bndProperties.load it
		}

		def packageInfoExcludes = []

		def exportPackage = bndProperties["Export-Package"]

		if (exportPackage) {
			def exportedPackages = exportPackage.split(",")

			packageInfoExcludes = exportedPackages.collect {
				"src/main/resources/" + it.replace('.' as char, '/' as char) + "/packageinfo"
			}

			println packageInfoExcludes
		}

		delete fileTree(dir: moduleDir, excludes: packageInfoExcludes, include: "**/packageinfo")
	}
}

deletePortalBuild {
	delete fileTree(dir: modulesDir, include: "**/portal.build")
}

diffArtifact << {
	def artifact = project.properties["art"].tokenize(":")

	def artifactGroupPath = "com/liferay"
	def artifactName = "com.liferay." + artifact[0]
	def artifactVersions = artifact[1 .. -1]

	if (artifactName in ["com.liferay.portal.impl", "com.liferay.portal.kernel", "com.liferay.util.bridges", "com.liferay.util.java", "com.liferay.util.taglib"]) {
		artifactGroupPath = "com/liferay/portal"
	}

	def combinations = [artifactVersions, ["-sources.jar", ".pom"]].combinations()

	def artifactDir = new File(temporaryDir, artifactName)

	artifactDir.mkdirs()

	combinations.each {
		def artifactVersion = it[0]
		def artifactSuffix = it[1]

		def url = "https://repository-cdn.liferay.com/nexus/service/local/repositories/liferay-public-releases/content/${artifactGroupPath}/${artifactName}/${artifactVersion}/${artifactName}-${artifactVersion}${artifactSuffix}"

		project.download {
			src url
			dest artifactDir
		}
	}

	def jarFileTree = fileTree(dir: artifactDir, include: "*.jar")

	jarFileTree.each {
		jarFile ->

		copy {
			from zipTree(jarFile)
			into new File(artifactDir, jarFile.name[0 .. -5])
		}
	}

	delete jarFileTree
}

dumpSnapshotVersions << {
	def jsonSlurper = new JsonSlurper()

	def modulesDirPath = modulesDir.toPath()

	def snapshotsDir = new File(modulesDir, ".snapshots")

	delete snapshotsDir

	def dateFormat = FastDateFormat.getInstance("yyyy-MM-dd HH:mm:ss.S z")

	def bndFileTree = fileTree(dir: modulesDir, excludes: ["**/bin/", "**/build/", "**/classes/", "**/node_modules/"], includes: ["apps/**/bnd.bnd", "core/**/bnd.bnd"])

	GParsPool.withPool {
		bndFileTree.eachParallel {
			bndFile ->

			def bndProperties = GUtil.loadProperties(bndFile)

			def bundleSymbolicName = bndProperties["Bundle-SymbolicName"]
			def bundleVersion = bndProperties["Bundle-Version"]

			def rootURL = "https://repository.liferay.com/nexus/service/local/repositories/liferay-public-snapshots/content"

			def result = null

			try {
				result = jsonSlurper.parse(new URL("${rootURL}/com/liferay/${bundleSymbolicName}/"), requestProperties: ["Accept": "application/json"])
			}
			catch (Exception e) {
				logger.info e.message
			}

			if (!result || !result.data) {
				return
			}

			Date latestLastModifiedDate = null
			String latestURL = null

			for (def bundleObj in result.data) {
				if (!bundleObj.text.endsWith("-SNAPSHOT")) {
					continue
				}

				def artResult = jsonSlurper.parse(new URL("${rootURL}${bundleObj.relativePath}"), requestProperties: ["Accept": "application/json"])

				for (def artObj in artResult.data) {
					if (!artObj.text.endsWith(".jar") || !Character.isDigit(artObj.text.charAt(artObj.text.size() - 5))) {
						continue
					}

					def artLastModifiedDate = dateFormat.parse(artObj.lastModified)
					def artURL = "${rootURL}${artObj.relativePath}"

					if (!latestLastModifiedDate || (artLastModifiedDate > latestLastModifiedDate)) {
						latestLastModifiedDate = artLastModifiedDate
						latestURL = artURL
					}
				}
			}

			if (!latestURL) {
				return
			}

			def jarURL = new URL("jar:${latestURL}!/")

			def jarURLConnection = (JarURLConnection)jarURL.openConnection()

			def latestLastModifiedTime = Long.valueOf(jarURLConnection.mainAttributes.getValue("Bnd-LastModified"))

			def snapshotDir = new File(snapshotsDir, String.valueOf(modulesDirPath.relativize(bndFile.parentFile.toPath())))

			snapshotDir.mkdirs()

			def snapshotFile = new File(snapshotDir, "snapshot.properties")

			snapshotFile.setText """\
snapshot.last.modified=${latestLastModifiedTime}
snapshot.url=${latestURL}""", "UTF-8"

			println snapshotFile
		}
	}
}

findClass << {
	assert project.properties["artGroup"] : "Please provide -PartGroup"
	assert project.properties["artName"] : "Please provide -PartName"
	assert project.properties["artVersion"] : "Please provide -PartVersion"
	assert project.properties["fqcn"] : "Please provide -Pfqcn"

	def cp = fqcn.replace('.' as char, '/' as char) + ".class"

	VersionNumber versionNumber = VersionNumber.parse(artVersion)

	while (true) {
		Dependency dependency = dependencies.create(group: artGroup, name: artName, version: versionNumber.toString())

		Configuration configuration = configurations.detachedConfiguration(dependency)

		configuration.transitive = false

		def artFile = null

		println "Downloading '${artGroup}:${artName}:${versionNumber}'..."

		try {
			artFile = configuration.singleFile
		}
		catch (Exception e) {
		}

		if (!artFile) {
			def newMajor = versionNumber.major
			def newMinor = versionNumber.minor

			if (newMajor == 0) {
				break
			}

			if (versionNumber.micro == 0) {
				newMajor++
			}
			else {
				newMinor++
			}

			versionNumber = new VersionNumber(newMajor, newMinor, 0, null)

			continue
		}

		def jarFile = new JarFile(artFile)

		def zipEntry = null

		jarFile.withCloseable {
			zipEntry = jarFile.getEntry(cp)
		}

		if (zipEntry) {
			println "Class '${fqcn}' found in '${artGroup}:${artName}:${versionNumber}'."

			return
		}

		versionNumber = new VersionNumber(versionNumber.major, versionNumber.minor, versionNumber.micro + 1, null)
	}
}

fixBnd << {
	ant.fixcrlf eof: "remove", fixlast: false, includes: "**/bnd.bnd", srcDir: modulesDir, tab: "add", tablength: 4

	def bndFiles = fileTree(dir: modulesDir, include: "**/bnd.bnd")

	bndFiles.each {
		it.text = it.text.trim()
	}
}

fixCache << {
	gradleCacheDir.eachFileRecurse(FileType.FILES) {
		def file ->

		if (file.name.endsWith(".pom")) {
			def charsetToolkit = new CharsetToolkit(file)
			def charset = charsetToolkit.charset.name()

			ant.fixcrlf encoding: charset, eol: "lf", file: file, fixlast: false, outputencoding: "UTF-8"
		}

		def sha1 = _getSHA1(file)

		def dir = file.parentFile

		if (dir.name != sha1) {
			def success = dir.renameTo(new File(dir.parentFile, sha1))

			if (success) {
				println "Succesfully moved " + dir
			}
			else {
				delete dir

				println "Deleted " + dir
			}
		}
	}
}

fixChangelogs << {
	def includePattern = project.properties["include"] ?: ""
	def limitVersion = project.properties["limitVersion"]

	if (includePattern) {
		includePattern = "**/${includePattern}/"
	}

	def changelogFileTree = fileTree(dir: modulesDir, exclude: "**/node_modules/", include: includePattern + "**/CHANGELOG.markdown")

	changelogFileTree.each {
		changelogFile ->

		def moduleDir = changelogFile.parentFile

		def bndFile = new File(moduleDir, "bnd.bnd")

		if (!bndFile.exists()) {
			return
		}

		Properties bndProperties = new Properties()

		bndFile.withInputStream {
			bndProperties.load it
		}

		def bundleSymbolicName = bndProperties.getProperty("Bundle-SymbolicName")

		def changelog = changelogFile.getText("UTF-8")

		changelog = changelog.normalize()
		changelog = changelog.trim()

		changelog = changelog.replaceAll(/### (\w+)\n\n/) {
			all, c ->

			"### ${c}\n"
		}

		changelog = changelog.replaceAll(/(?m)^#([\d|A-Z])/) {
			all, c ->

			"# ${c}"
		}

		changelog = changelog.replaceAll(/(?m)^## ([A-Z])/) {
			all, c ->

			"### ${c}"
		}

		changelog = changelog.replaceAll(/\[([A-Z]+)-(\d+)\]: https:\/\/issues\.liferay\.com\/browse\/.+/) {
			all, prefix, number ->

			"[${prefix}-${number}]: https://issues.liferay.com/browse/${prefix}-${number}"
		}

		changelog = changelog.replaceAll(/\[Liferay ([\w\s]+)\]: https:\/\/github\.com\/liferay\/liferay-portal\/tree\/master\/modules\/([a-z]+)\/(.+)/) {
			all, name, groupName, dirName ->

			dirName = name.toLowerCase()
			dirName = dirName.replace(' ' as char, '-' as char)

			"[Liferay ${name}]: https://github.com/liferay/liferay-portal/tree/master/modules/${groupName}/${dirName}"
		}

		changelog = changelog.replaceAll(/\[(.+)\]: http.+\n*\r*/) {
			all, label ->

			def matcher = changelog =~ Pattern.compile(Pattern.quote("[${label}]"))

			if (matcher.count > 1) {
				return all
			}
			else {
				return ""
			}
		}

		changelog = changelog.replace("*(Unreleased)*", "1970-01-01")

		def versions = []

		def pattern = ~/## (\d+\.\d+\.\d+) - \d\d\d\d-\d\d-\d\d( \[[A-Z]+\])?/

		changelog.eachMatch(pattern) {
			all, ver, comment ->

			if (limitVersion && (limitVersion != ver)) {
				return
			}

			versions << ver
		}

		def versionDateMap = new ConcurrentHashMap<String, Date>()

		GParsPool.withPool {
			versions.eachParallel {
				ver ->

				def xmlSlurper = new XmlSlurper()

				def rootNode

				try {
					rootNode = xmlSlurper.parse("https://repository.liferay.com/nexus/service/local/repositories/liferay-public-releases/content/com/liferay/${bundleSymbolicName}/${ver}/${bundleSymbolicName}-${ver}.jar?describe=info")
				}
				catch (Exception e) {
					println e.message

					versionDateMap[ver] = ""

					return
				}

				def calendar = Calendar.getInstance(TimeZone.getTimeZone("America/Los_Angeles"))

				calendar.timeInMillis = rootNode.data.uploaded.text().toLong()

				def date = calendar.format("yyyy-MM-dd")

				versionDateMap[ver] = date

				println "${bundleSymbolicName}: ${ver} - ${date}"
			}
		}

		changelog = changelog.replaceAll(pattern) {
			all, ver, comment ->

			if (limitVersion && (limitVersion != ver)) {
				return all
			}

			def commentSuffix = comment ?: ""
			def date = versionDateMap[ver]

			if (date) {
				return "## ${ver} - ${date}${commentSuffix}"
			}

			return "## ${ver} - *(Unreleased)*${commentSuffix}"
		}

		changelogFile.setText changelog.denormalize(), "UTF-8"
	}
}

fixMarkerFiles << {
	def markerFileTree = fileTree(dir: modulesDir, includes: ["**/.lfrbuild-*", "**/.lfrrelease-"])

	markerFileTree.each {
		it.text = ""
	}
}

fixPackageInfo << {
	def rootDir = new File(portalDir, "portal-kernel/src/com/liferay")
	def oldRootDir = new File(portal62Dir, "portal-service/src/com/liferay")

	def rootDirPath = rootDir.toPath()

	rootDir.eachDirRecurse {
		dir ->

		def packageInfoFile = new File(dir, "packageinfo")

		def javaFileTree = fileTree(dir: dir, include: "*.java")

		if (javaFileTree.empty) {
			if (packageInfoFile.exists()) {
				delete packageInfoFile

				println "Deleted " + packageInfoFile
			}

			return
		}

		def relativePath = rootDirPath.relativize(dir.toPath()).toString()

		def oldDir = new File(oldRootDir, relativePath)

		if (oldDir.exists()) {
			if (!packageInfoFile.exists() || !packageInfoFile.text.startsWith("version 7")) {
				packageInfoFile.text = "version 7.0.0"
			}
		}
		else {
			if (!packageInfoFile.exists() || packageInfoFile.text.startsWith("version 7")) {
				packageInfoFile.text = "version 1.0.0"
			}
		}
	}
}

fixPluginTags << {
	def pluginTagsPropertiesFile = file("plugin-tags.properties")

	def pluginTagsProperties = GUtil.loadProperties(pluginTagsPropertiesFile)

	def buildGradleFileTree = fileTree(dir: new File(modulesDir, "sdk"), include: "*/build.gradle")

	buildGradleFileTree.each {
		buildGradleFile ->

		def pluginDir = buildGradleFile.parentFile

		def bndBndFile = new File(pluginDir, "bnd.bnd")

		if (!bndBndFile.text.contains("Bundle-Description:")) {
			return
		}

		def pluginName = pluginDir.name

		def tags = new TreeSet<String>()

		def tagsString = pluginTagsProperties.getProperty(pluginName)

		if (tagsString) {
			tags.addAll tagsString.tokenize(",")
		}

		def buildGradle = buildGradleFile.text

		if (!buildGradle.contains('apply plugin: "com.gradle.plugin-publish"')) {
			buildGradle = """\
apply plugin: \"com.gradle.plugin-publish\"
${buildGradle}"""
		}

		def matcher = buildGradle =~ /pluginBundle \{\s+tags = \["(.+)"\]\s+\}/

		if (!matcher.find()) {
			tagsString = tags.join('", "')

			buildGradle = """\
${buildGradle}

pluginBundle {
	tags = [\"${tagsString}\"]
}"""
		}
		else {
			tagsString = matcher.group(1)

			tags.addAll tagsString.tokenize('", "')

			tagsString = tags.join('", "')

			buildGradle = matcher.replaceFirst """\
pluginBundle {
	tags = [\"${tagsString}\"]
}"""
		}

		pluginTagsProperties.setProperty pluginName, tags.join(",")

		buildGradleFile.text = buildGradle.trim()
	}

	pluginTagsPropertiesFile.withWriter {
		pluginTagsProperties.store it, null
	}
}

fixProjectTemplatesVelocity << {
	def velocityFiles = fileTree(dir: modulesDir, include: "sdk/project-templates-*/")

	velocityFiles.each {
		def content = it.text

		content = content.replaceAll(/#if\s*\(\s*(.+)\s*\)/) {
			all, group ->

			"#if (${group.trim()})"
		}

		it.setText content, "UTF-8"
	}
}

fixRelengIgnoreVersions << {
	modulesDir.traverse(
		preDir: {
			moduleDir ->

			def bndBndFile = new File(moduleDir, "bnd.bnd")

			if (bndBndFile.exists()) {
				def relengIgnoreFile = new File(moduleDir, ".lfrbuild-releng-ignore")

				if (relengIgnoreFile.exists()) {
					def bnd = bndBndFile.getText("UTF-8")

					String newBnd = bnd.replaceFirst(/Bundle-Version: \d+\.\d+\.\d+/, "Bundle-Version: 1.0.0")

					if (bnd != newBnd) {
						bndBndFile.setText newBnd, "UTF-8"

						println "Saved ${bndBndFile}"
					}
				}

				return FileVisitResult.SKIP_SUBTREE
			}

			return FileVisitResult.CONTINUE
		})
}

fixSeparateRepoDeps << {
	def buildGradleFileTree = fileTree(dir: modulesDir, include: "**/build.gradle")

	def fixProjectPath = {
		dir ->

		File subRootDir = dir.parentFile

		while (true) {
			File settingsGradleFile = new File(subRootDir, "settings.gradle")

			if (settingsGradleFile.exists()) {
				break;
			}

			subRootDir = subRootDir.parentFile
		}

		URI subRootURI = subRootDir.toURI()

		String dirName = subRootURI.relativize(dir.toURI())

		dirName = dirName[0 .. -2]

		dirName.replace("/" as char, ":" as char)
	}

	buildGradleFileTree.each {
		buildGradleFile ->

		def buildGradle = buildGradleFile.text

		if (!buildGradle.contains("project(\"")) {
			return
		}

		buildGradle = buildGradle.replaceAll(/project\(":(.+)"\)/) {
			String projectDependency = it[0]
			String projectPath = it[1]

			def projectDirName = projectPath.replace(':' as char, File.separatorChar)

			def projectDir = new File(modulesDir, projectDirName)

			if (!projectDir.exists()) {
				println "Path ${projectPath} is not relative to the modules dir, so it's probably already okay"

				return projectDependency
			}

			projectPath = fixProjectPath(projectDir)

			"project(\":${projectPath}\")"
		}

		buildGradleFile.text = buildGradle
	}
}

fixShrinkwrap << {
	def shrinkwrapFileTree = fileTree(dir: modulesDir, include: "**/npm-shrinkwrap.json")

	shrinkwrapFileTree.each {
		shrinkwrapFile ->

		shrinkwrapFile.text = shrinkwrapFile.text.replaceAll(/\t+"(?:from|resolved)": "http.+",*\r*\n/, "")
	}
}

fixTestClasspaths << {
	def taskName = project.properties["taskName"] ?: "test"

	def configurationName

	if (taskName == "compileJSP") {
		configurationName = "compileOnly"
	}
	else if (taskName == "test") {
		def buildGradleFile = new File(modulesDir, "build.gradle")

		assert buildGradleFile.text.contains("ignoreFailures = false") : "Please configure build.gradle to not ignore test failures."

		configurationName = "testCompile"
	}
	else {
		throw new GradleException("Unsupported task name '${taskName}'")
	}

	def gradlewFile = new File(portalDir, "gradlew.bat")

	def gradlewExecutable = gradlewFile.absolutePath

	def liferayHomeDir = new File(portalDir.parentFile, "bundles")

	def liferayHome = liferayHomeDir.absolutePath.replace(File.separatorChar, '/' as char)

	def collectPetraErrorDependencies = {
		map, dir ->

		if (!dir.exists()) {
			return
		}

		dir.eachDir {
			def petraBndFile = new File(it, "bnd.bnd")

			if (!petraBndFile.exists()) {
				return
			}

			def name = it.name.substring(6)

			def petraDependency = "${configurationName} group: \"com.liferay\", name: \"com.liferay.petra.${name}\", version: \"1.0.0\""

			map["error: package com.liferay.petra.${name} does not exist"] = petraDependency
			map["java.lang.NoClassDefFoundError: com/liferay/petra/${name}/"] = petraDependency
		}
	}

	def errorDependencies = [
		'error: package com.liferay.portal.json': "${configurationName} group: \"com.liferay.portal\", name: \"com.liferay.portal.impl\", version: \"2.0.0\"",
		'error: package com.liferay.portal.kernel.': "${configurationName} group: \"com.liferay.portal\", name: \"com.liferay.portal.kernel\", version: \"2.0.0\"",
		'error: package com.liferay.portal.language': "${configurationName} group: \"com.liferay.portal\", name: \"com.liferay.portal.impl\", version: \"2.0.0\"",
		'java.lang.ClassNotFoundException: com.germinus.easyconf.': "${configurationName} group: \"easyconf\", name: \"easyconf\", version: \"0.9.5\"",
		'java.lang.ClassNotFoundException: org.apache.commons.httpclient.': "${configurationName} group: \"commons-httpclient\", name: \"commons-httpclient\", version: \"3.1\"",
		'java.lang.NoClassDefFoundError: com/liferay/registry/': "${configurationName} group: \"com.liferay\", name: \"com.liferay.registry.api\", version: \"1.0.0\""
	]

	collectPetraErrorDependencies(errorDependencies, new File(modulesDir, "apps/foundation/petra"))
	collectPetraErrorDependencies(errorDependencies, new File(modulesDir, "apps/static/petra"))
	collectPetraErrorDependencies(errorDependencies, new File(modulesDir, "core/petra"))

	def modulesRootDir = project.properties["modulesRootDir"] ?: modulesDir

	modulesRootDir = file(modulesRootDir)

	modulesRootDir.traverse(
		preDir: {
			moduleDir ->

			def fixedFile = new File(moduleDir, ".test-classpath-fixed")
			def ignoreFile = new File(moduleDir, ".test-classpath-ignore")

			if (fixedFile.exists() || ignoreFile.exists()) {
				return FileVisitResult.SKIP_SUBTREE
			}

			delete new File(moduleDir, "settings.gradle")

			def bndFile = new File(moduleDir, "bnd.bnd")

			if (!bndFile.exists()) {
				return FileVisitResult.CONTINUE
			}

			if (taskName == "test") {
				File srcTestDir = new File(moduleDir, "src/test")

				if (!srcTestDir.exists()) {
					return FileVisitResult.SKIP_SUBTREE
				}
			}

			println "Testing ${moduleDir}..."

			def gradleFile = new File(moduleDir, "build.gradle")

			while (true) {
				def errorStream = new ByteArrayOutputStream()
				def outputStream = new ByteArrayOutputStream()

				def execResult = exec {
					args taskName, "-a", "--daemon", "--parallel"
					args "-Dblacklist.cfg.name=com.liferay.portal.bundle.blacklist.internal.BundleBlacklistConfiguration.cfg"
					args "-Dliferay.home=${liferayHome}"

					errorOutput = errorStream
					executable = gradlewExecutable
					ignoreExitValue = true
					standardOutput = outputStream
					workingDir = moduleDir
				}

				def errorString = errorStream.toString()
				def outputString = outputStream.toString()

				println errorString
				println outputString

				if (execResult.exitValue == 0) {
					break
				}

				def added = false

				errorDependencies.each {
					err, dep ->

					if (errorString.contains(err) || outputString.contains(err)) {
						added = true

						gradleFile.text = gradleFile.text.replace('dependencies {', """\
dependencies {
	${dep}""")

						println "Added '${dep}' to ${gradleFile}"
					}
				}

				if (!added) {
					throw new GradleException("Unable to fix test classpath of ${moduleDir}")
				}
			}

			fixedFile.createNewFile()

			return FileVisitResult.SKIP_SUBTREE
		},
		type: FileType.DIRECTORIES)
}

fixWrongPrepNext << {
	def bndBndFileTree = fileTree(dir: modulesDir, include: "**/bnd.bnd")

	def xmlSlurper = new XmlSlurper()

	bndBndFileTree.each {
		bndBndFile ->

		def bndBndProperties = GUtil.loadProperties(bndBndFile)

		def bundleVersion = bndBndProperties["Bundle-Version"]

		if (!bundleVersion.startsWith("0.0.")) {
			return
		}

		def bundleSymbolicName = bndBndProperties["Bundle-SymbolicName"]

		def artifactResolutionNode = xmlSlurper.parse("https://repository.liferay.com/nexus/service/local/artifact/maven/resolve?g=com.liferay&a=${bundleSymbolicName}&v=RELEASE&r=liferay-public-releases")

		def latestVersion = artifactResolutionNode.data.version.text()

		VersionNumber latestVersionNumber = VersionNumber.parse(latestVersion)

		VersionNumber nextVersionNumber = new VersionNumber(latestVersionNumber.major, latestVersionNumber.minor, latestVersionNumber.micro + 1, null)

		bndBndFile.text = bndBndFile.text.replace("Bundle-Version: ${bundleVersion}", "Bundle-Version: ${nextVersionNumber}")
	}
}

initApps << {
	def buildGradleTemplateFile = rootProject.file("app_build_gradle.tmpl")

	def appFileTree = fileTree(dir: modulesDir, include: "**/app.bnd")

	appFileTree.each {
		def dir = it.parentFile

		copy {
			from buildGradleTemplateFile
			into dir

			rename {
				"build.gradle"
			}
		}
	}
}

initPortalBuild {
	dependsOn deletePortalBuild

	doLast {
		def buildProperties = new Properties()

		def buildPropertiesFiles = new File(portalDir, "build.properties")

		buildPropertiesFiles.withInputStream {
			buildProperties.load it
		}

		def excludes = buildProperties["build.modules.excludes"].tokenize(",")

		["**/bin/", "sdk/*/samples/", "sdk/gradle-templates/classes/", "sdk/gradle-templates/src/"].each {
			excludes.add it
		}

		def includes = buildProperties["build.modules.includes"].tokenize(",")

		def includedFileTree = fileTree(dir: modulesDir, excludes: excludes, includes: includes)

		includedFileTree.each {
			def dir = it.parentFile

			def settingsGradleFile = new File(dir, "settings.gradle")

			if (settingsGradleFile.exists()) {
				return
			}

			def portalBuildFile = new File(dir, "portal.build")

			portalBuildFile.createNewFile()
		}
	}
}

initSeparateRepos << {
	def excludeReadOnly = Boolean.getBoolean("exclude.read.only")

	def gitRepoFileTree = fileTree(dir: modulesDir, include: "**/.gitrepo")
	def modulesDirPath = modulesDir.toPath()

	def buildGradleTemplateFile = rootProject.file("separate_repos_build_gradle.tmpl")
	def gradlePropertiesTemplateFile = rootProject.file("separate_repos_gradle_properties.tmpl")
	def settingsGradleTemplateFile = rootProject.file("separate_repos_settings_gradle.tmpl")

	def buildGradleTemplate = buildGradleTemplateFile.text.normalize()
	def gradlePropertiesTemplate = gradlePropertiesTemplateFile.text.normalize()
	def settingsGradleTemplate = settingsGradleTemplateFile.text.normalize()

	gitRepoFileTree.each {
		gitRepoFile ->

		if (excludeReadOnly && gitRepoFile.text.contains("mode = pull")) {
			return
		}

		def gitRepoDir = gitRepoFile.parentFile

		def buildGradleFile = new File(gitRepoDir, "build.gradle")
		def gradlePropertiesFile = new File(gitRepoDir, "gradle.properties")
		def settingsGradleFile = new File(gitRepoDir, "settings.gradle")

		def projectPathPrefix = modulesDirPath.relativize(gitRepoDir.toPath()).toString()

		projectPathPrefix = ":" + projectPathPrefix.replace(File.separatorChar, ':' as char)

		buildGradleFile.setText(buildGradleTemplate, "UTF-8")
		gradlePropertiesFile.setText(gradlePropertiesTemplate.replace('[$PROJECT_PATH_PREFIX$]', projectPathPrefix), "ISO-8859-1")
		settingsGradleFile.setText(settingsGradleTemplate, "UTF-8")

		println "Initialized " + gitRepoDir
	}
}

initSeparateReposGit << {
	def gitRepoFileTree = fileTree(dir: modulesDir, include: "**/.gitrepo")

	// def gitAttributesTemplateFile = rootProject.file("separate_repos_gitattributes.tmpl")
	def gitIgnoreTemplateFile = rootProject.file("separate_repos_gitignore.tmpl")

	// def gitAttributesTemplate = gitAttributesTemplateFile.text.normalize()
	def gitIgnoreTemplate = gitIgnoreTemplateFile.text.normalize()

	def excludeReadOnly = Boolean.getBoolean("exclude.read.only")

	gitRepoFileTree.each {
		gitRepoFile ->

		if (excludeReadOnly && gitRepoFile.text.contains("mode = pull")) {
			return
		}

		def gitRepoDir = gitRepoFile.parentFile

		def gitIgnoreFile = new File(gitRepoDir, ".gitignore")

		gitIgnoreFile.setText gitIgnoreTemplate, "UTF-8"

		// def gitAttributesFile = new File(gitRepoDir, ".gitattributes")

		// gitAttributesFile.setText gitAttributesTemplate, "UTF-8"
	}
}

initTestIntegration << {
	def bndBndFileTree = fileTree(dir: modulesDir, include: "**/bnd.bnd")

	bndBndFileTree.each {
		bndBndFile ->

		def moduleDir = bndBndFile.parentFile

		def buildGradleFile = new File(moduleDir, "build.gradle")

		if (!buildGradleFile.exists()) {
			return
		}

		def buildGradle = buildGradleFile.text

		if (buildGradle.contains('apply plugin: "com.liferay.test.integration')) {
			return
		}

		def srcTestIntegrationDir = new File(moduleDir, "src/testIntegration")

		if (!srcTestIntegrationDir.exists()) {
			return
		}

		def testIntegrationPluginId = "com.liferay.test.integration"

		def skipManagedAppServerFile = new File(srcTestIntegrationDir, "resources/skip.managed.app.server")

		if (skipManagedAppServerFile.exists()) {
			testIntegrationPluginId = "com.liferay.test.integration.base"

			delete skipManagedAppServerFile
		}

		buildGradleFile.text = """\
apply plugin: \"${testIntegrationPluginId}\"

${buildGradle}"""
	}
}

moveLPS64532 << {
	def buildGradleFiles = fileTree(dir: modulesDir, include: "**/build.gradle")

	def destRootDir = new File(modulesDir, ".releng")
	def modulesDirPath = modulesDir.toPath()

	buildGradleFiles.each {
		buildGradleFile ->

		def dir = buildGradleFile.parentFile

		def relativePath = modulesDirPath.relativize(dir.toPath()).toString()

		def destDir = new File(destRootDir, relativePath)

		destDir.mkdirs()

		["artifact.properties", "src/main/resources/META-INF/liferay-releng.changelog"].each {
			File srcFile = new File(dir, it)

			if (srcFile.exists()) {
				def destFile = new File(destDir, srcFile.name)

				def moved = srcFile.renameTo destFile

				if (moved) {
					println "${srcFile} -> ${destFile}"
				}
				else {
					throw new GradleException("Unable to move ${srcFile} to ${destFile}")
				}
			}
		}
	}
}

moveModules {
	finalizedBy replaceBuildXml
}

moveModules << {
	File marketplaceDir = new File(modulesDir, "apps/marketplace")

	if (marketplaceDir.exists()) {
		throw new GradleException("Please rename " + marketplaceDir + ", it messes with the bnd.bnd relative path replacement")
	}

	def moveDirs = [:]
	def moveParentDirs = new HashSet<File>()

	def movesFile = file("moves.csv")

	def moveLines = movesFile.readLines()

	moveLines.each {
		if (!it.startsWith("modules")) {
			println "Ignoring " + it

			return
		}

		def tokens = it.tokenize(",")

		def oldParentDir = new File(modulesDir.parentFile, tokens[0])
		def dirName = tokens[1]
		def newParentDir = new File(modulesDir, tokens[2])

		moveParentDirs << newParentDir

		def oldDir = new File(oldParentDir, dirName)

		if (!oldDir.exists()) {
			println "Ignoring ${oldDir} because it does not exist"

			return
		}

		def newDir = new File(newParentDir, dirName)

		newParentDir.mkdirs()

		def dir = newParentDir

		while ((dir != null) && (dir != modulesDir)) {
			def buildXmlFile = new File(dir, "build.xml")

			if (!buildXmlFile.exists()) {
				buildXmlFile.text = "REPLACEME!"
			}

			dir = dir.parentFile
		}

		def moved = oldDir.renameTo(newDir)

		if (!moved) {
			throw new GradleException("Unable to move ${oldDir} to ${newDir}")
		}

		println "Moved ${oldDir} to ${newDir}"

		moveDirs[oldDir] = newDir
	}

	Closure doReplace = {
		file, replaceClosure ->

		def content = file.text

		def newContent = content

		moveDirs.each {
			oldDir, newDir ->

			newContent = newContent.replace replaceClosure(oldDir), replaceClosure(newDir)
		}

		if (content != newContent) {
			file.text = newContent

			println "Updated " + file
		}
	}

	if (Boolean.getBoolean("skip.replace")) {
		return
	}

	// Replace relative paths in bnd.bnd

	moveParentDirs.each {
		parentDir ->

		def bndFileTree = fileTree(dir: parentDir, exclude: "**/src/**/*.bnd", include: "**/*.bnd")

		bndFileTree.each {
			bndFile ->

			def bndDir = bndFile.parentFile

			def bndDirPath = bndDir.toPath()

			def content = bndFile.text

			def newContent = content.replaceAll(
				/((?:\.\.\/)+[\w-]+?)\//,
				{
					def pointedFile = new File(bndDir, it[1])

					while (!pointedFile.exists()) {
						def dir = pointedFile.parentFile.parentFile

						if (dir == null) {
							pointedFile = null

							break
						}

						pointedFile = new File(pointedFile.parentFile.parentFile, pointedFile.name)
					}

					if (pointedFile == null) {
						return null
					}

					def pointedPath = bndDirPath.relativize(pointedFile.toPath()).toString()

					return pointedPath.replace(File.separatorChar, '/' as char) + "/"
				})

			if (content != newContent) {
				bndFile.text = newContent

				println "Updated " + bndFile
			}
		}
	}

	// Replace project paths in build.gradle

	def buildGradleFiles = fileTree(dir: modulesDir, include: "**/build.gradle")

	buildGradleFiles.each {
		doReplace it, {
			dir ->

			def modulesDirPath = modulesDir.toPath()

			def path = modulesDirPath.relativize(dir.toPath()).toString()

			path = path.replace(File.separatorChar, ':' as char)
			path = path.replace('/' as char, ':' as char)

			path = "\":" + path + ":"

			return path
		}

		doReplace it, {
			dir ->

			def modulesDirPath = modulesDir.toPath()

			def path = modulesDirPath.relativize(dir.toPath()).toString()

			path = path.replace(File.separatorChar, ':' as char)
			path = path.replace('/' as char, ':' as char)

			path = "\":" + path + "\""

			return path
		}
	}

	// Replace file paths source-formatter.properties and other files

	FileTree fileTree = fileTree(dir: modulesDir.parentFile, includes: ["build.properties", "source-formatter.properties", "modules/**/*.bnd", "modules/**/*.java"])

	fileTree.each {
		doReplace it, {
			dir ->

			def modulesDirPath = modulesDir.toPath()

			def path = modulesDirPath.relativize(dir.toPath()).toString()

			return "modules/" + path.replace(File.separatorChar, '/' as char) + "/"
		}
	}
}

moveStatic << {
	def staticFileTree = fileTree(dir: modulesDir, include: "**/.lfrbuild-static")

	staticFileTree.each {
		def dir = it.parentFile

		println dir
	}
}

printExtensions << {
	Set<String> extensions = new TreeSet<String>()

	def rootDir = portalDir

	if (project.hasProperty("dir")) {
		rootDir = new File(rootDir, dir)
	}

	def excludedDirNames = ["build", "bin", ".gradle", ".git", "classes", "node_modules", "test-classes", "build_gradle", "tmp"]

	rootDir.traverse(
		preDir: {
			if (excludedDirNames.contains(it.name)) {
				return FileVisitResult.SKIP_SUBTREE
			}

			return FileVisitResult.CONTINUE
		},
		type: FileType.FILES,
		visit: {
			def fileName = it.name

			def pos = fileName.lastIndexOf('.')

			if (pos == -1) {
				return
			}

			def extension = fileName.substring(pos + 1)

			if (extensions.contains(extension)) {
				return
			}

			println "Reading ${it}"

			if (!project.hasProperty("content") || it.text.contains(content)) {
				extensions << extension
			}
		})

	println extensions
}

printPluginChangelog << {
	assert project.properties["pluginName"] : "Please provide -PpluginName"

	def toolName = project.properties["toolName"] ?: pluginName

	def getBundleNameSymbolicName = {
		dir ->

		def properties = GUtil.loadProperties(new File(modulesDir, "${dir}/bnd.bnd"))

		[properties["Bundle-Name"], properties["Bundle-SymbolicName"]]
	}

	def (pluginFullName, pluginSymbolicName) = getBundleNameSymbolicName("sdk/gradle-plugins-${pluginName}")
	def (toolFullName, toolSymbolicName) = getBundleNameSymbolicName("util/${toolName}")

	def pluginChangelog = new File(modulesDir, "sdk/gradle-plugins-${pluginName}/CHANGELOG.markdown")

	def oldChangelog = pluginChangelog.text

	def gradlePluginsChangelog = new File(modulesDir, "sdk/gradle-plugins/CHANGELOG.markdown")

	def changelog = StringBuilder.newInstance()
	def ticketLines = new TreeSet<>()

	def xmlSlurper = new XmlSlurper()

	gradlePluginsChangelog.text.eachMatch(/- \[([A-Z]+-\d+)\]:\s+Update\s+the\s+\[${pluginFullName}]\s+dependency\s+to\s+version\s+(\d+\.\d+\.\d+)\.\s+- \[([A-Z]+-\d+)\]:\s+Update\s+the\s+\[${toolFullName}]\s+dependency\s+to\s+version\s+(\d+\.\d+\.\d+)\./) {
		all, ticket, pluginVersion, toolTicket, toolVersion ->

		if (oldChangelog.contains("## ${pluginVersion} - ")) {
			return
		}

		changelog << """\
## ${pluginVersion} - 1970-01-01

### Changed
- [${ticket}]: Update the [${toolFullName}] dependency to version ${toolVersion}.

"""

		ticketLines << "[${ticket}]: https://issues.liferay.com/browse/${ticket}"
	}

	ticketLines.each {
		changelog << it
		changelog << System.lineSeparator()
	}

	println changelog
}

removeGitIgnore << {
	modulesDir.traverse(
		preDir: {
			if (it.name == "node_modules") {
				return FileVisitResult.SKIP_SUBTREE
			}

			def gitRepoFile = new File(it, ".gitrepo")

			if (!gitRepoFile.exists()) {
				def buildGradleFile = new File(it, "build.gradle")

				if (buildGradleFile.exists() && buildGradleFile.text.contains("com.liferay.root.defaults.plugin")) {
					delete buildGradleFile
				}

				def gitIgnoreFile = new File(it, ".gitignore")

				if (gitIgnoreFile.exists() && gitIgnoreFile.text.contains(".classpath")) {
					delete gitIgnoreFile
				}
			}

			return FileVisitResult.CONTINUE
		},
		type: FileType.DIRECTORIES
	)
}

removeLanguageAutomaticLabels << {
	portalDir.traverse(
		nameFilter: ~/Language_.+\.properties/,
		preDir: {
			def dirName = it.name

			if (dirName in ["bin", "build", "classes", "node_modules", "sdk"]) {
				return FileVisitResult.SKIP_SUBTREE
			}

			def gitRepoFile = new File(it, ".gitrepo")

			if (gitRepoFile.exists() && gitRepoFile.text.contains("mode = pull")) {
				return FileVisitResult.SKIP_SUBTREE
			}
		},
		type: FileType.FILES
	) {
		def text = it.getText("UTF-8")

		text = text.replace(" (Automatic Copy)", "")
		text = text.replace(" (Automatic Translation)", "")

		it.setText text, "UTF-8"

		println "Updated ${it}"
	}
}

removeOldSubrepos << {
	modulesDir.traverse(
		preDir: {
			def gitRepoFile = new File(it, ".gitrepo")
			def settingsGradleFile = new File(it, "settings.gradle")

			if (!gitRepoFile.exists() && settingsGradleFile.exists() && settingsGradleFile.text.contains("com.liferay.settings.plugin")) {
				delete settingsGradleFile
				delete new File(it, ".gitignore")
				delete new File(it, "build.gradle")
				delete new File(it, "gradle.properties")

				return FileVisitResult.SKIP_SUBTREE
			}

			return FileVisitResult.CONTINUE
		},
		type: FileType.DIRECTORIES
	)
}

removeSnapshots << {
	assert project.properties["dirName"] : "Please provide -PdirName"

	def lpkgFileTree = fileTree(dir: new File(portalDir, "../bundles/osgi/marketplace"), include: "*API.lpkg")

	Closure<String> convertModuleVersion = {
		moduleVersion ->

		def moduleVersionNumber = VersionNumber.parse(moduleVersion)

		moduleVersionNumber = new VersionNumber(moduleVersionNumber.major, moduleVersionNumber.minor, 0, null)

		moduleVersionNumber as String
	}

	def moduleVersions = lpkgFileTree.collectEntries {
		lpkgFile ->

		def zipDir = new File(temporaryDir, lpkgFile.name[0..-5])

		copy {
			from zipTree(lpkgFile)
			into zipDir
		}

		def zipFileTree = fileTree(dir: zipDir, include: "*.jar")

		zipFileTree.collectEntries {
			zipFile ->

			def pos = zipFile.name.indexOf('-')

			[(zipFile.name.substring(0, pos)) : convertModuleVersion(zipFile.name.substring(pos + 1, zipFile.name.length() - 4))]
		}
	}

	def jarFileTree = fileTree(dir: new File(portalDir.parentFile, "bundles"), exclude: "osgi/state/", includes: ["osgi/**/*.jar", "tomcat-*/lib/ext/*.jar", "tomcat-*/webapps/ROOT/WEB-INF/lib/portal-*.jar", "tomcat-*/webapps/ROOT/WEB-INF/lib/util-*.jar"])

	jarFileTree.each {
		file ->

		def jarFile = new JarFile(file)

		jarFile.withCloseable {
			def attributes = jarFile.manifest.mainAttributes

			def moduleName = attributes.getValue("Bundle-SymbolicName")

			if (!moduleName) {
				return
			}

			def pos = moduleName.indexOf(';')

			if (pos != -1) {
				moduleName = moduleName.substring(0, pos)
			}

			def moduleVersion = attributes.getValue("Bundle-Version")

			moduleVersions[moduleName] = convertModuleVersion(moduleVersion)
		}
	}

	println moduleVersions

	def buildGradleFileTree = fileTree(dir: new File(portalDir.parentFile, dirName), excludes: ["**/bin/", "**/build/", "**/classes/", "**/node_modules/"], include: "**/build.gradle")

	buildGradleFileTree.each {
		buildGradleFile ->

		def buildGradle = buildGradleFile.getText("UTF-8")

		moduleVersions.each {
			moduleName, moduleVersion ->

			def pattern = "\\Q\"${moduleName}\\E\",\\s*(transitive:\\s*false,\\s*)?version:\\s*\"\\d+\\.\\d+\\.\\d+-\\d+\\.\\d+-\\d+\""

			buildGradle = buildGradle.replaceFirst(pattern) {
				all, transitive ->

				if (!transitive) {
					transitive = ""
				}

				"\"${moduleName}\", ${transitive}version: \"${moduleVersion}\""
			}
		}

		buildGradleFile.setText buildGradle, "UTF-8"

		println "Written ${buildGradleFile}"
	}
}

removeTouch << {
	def touchFileTree = fileTree(dir: modulesDir, include: "**/.touch")

	touchFileTree.each {
		touchFile ->

		def touchFilePath = touchFile.absolutePath

		touchFilePath = touchFilePath.replace(File.separatorChar, '/' as char)

		if (!touchFilePath.endsWith("/src/main/resources/.touch")) {
			println "Ignoring ${touchFile}"

			return
		}

		def srcDir = touchFile.parentFile.parentFile.parentFile

		def testDir = new File(srcDir, "test")
		def testIntegrationDir = new File(srcDir, "testIntegration")

		if (testDir.exists() || testIntegrationDir.exists()) {
			delete touchFile
		}
	}
}

renameBuildFiles << {
	def buildFiles = fileTree(dir: modulesDir, includes: ["**/portal.build", "**/static.build"])

	buildFiles.each {
		def suffix = it.name[0 .. - 7]

		def newFile = new File(it.parentFile, ".lfrbuild-${suffix}")

		def renamed = it.renameTo newFile

		if (renamed) {
			println "Renamed ${it} into ${newFile}"
		}
		else {
			throw new GradleException("Unable to rename ${it} into ${newFile}")
		}
	}
}

replaceBuildCIPortalFiles << {
	def dirExcludes = [
		"apps/collaboration/",
		"apps/forms-and-workflow/",
		"apps/foundation/",
		"apps/ip-geocoder/",
		"apps/marketplace/",
		"apps/static/",
		"apps/sync/",
		"apps/web-experience/",
		"core/",
		"util/"
	]

	def buildPortalFileTree = fileTree(dir: modulesDir, excludes: dirExcludes, include: "**/.lfrbuild-portal")

	buildPortalFileTree.each {
		File buildCIFile = new File(it.parentFile, ".lfrbuild-ci")

		buildCIFile.createNewFile()
	}

	delete buildPortalFileTree
}

replaceBuildXml << {
	def buildXmlFileTree = fileTree(dir: modulesDir, include: "**/build.xml")

	def buildModuleXmlPath = new File(modulesDir, "build-module.xml").toPath()

	buildXmlFileTree.each {
		def buildXmlFile ->

		if (buildXmlFile.parentFile.name != "samples") {
			def parentPath = buildXmlFile.parentFile.toPath()

			def content = buildXmlFile.text

			if (content.contains("build-theme.xml")) {
				return
			}

			def buildModuleXmlFileName = parentPath.relativize(buildModuleXmlPath).toString()

			buildModuleXmlFileName = buildModuleXmlFileName.replace('\\', '/')

			buildXmlFile.text = """\
<?xml version=\"1.0\"?>
<!DOCTYPE project>

<project>
	<import file=\"${buildModuleXmlFileName}\" />
</project>"""
		}
	}
}

replaceProjectDeps << {
	def projectDepsReplacements = [:]

	def group = "com.liferay"

	def groupCacheDir = new File(gradleCacheDir, group)

	def projectDepsFile = file("project_deps.txt")

	projectDepsFile.each {
		projectDep ->

		def index = projectDep.lastIndexOf(":")

		def name = projectDep.substring(index + 1, projectDep.length() - 2)

		def artifactName = group + "." + name.replace('-' as char, '.' as char)

		def artifactCacheDir = new File(groupCacheDir, artifactName)

		if (!artifactCacheDir.exists()) {
			println "Unable to find ${artifactCacheDir}"

			return
		}

		def version = artifactCacheDir.list().first()

		def artifactDep = "group: \"${group}\", name: \"${artifactName}\", version: \"${version}\""

		projectDepsReplacements[projectDep] = artifactDep
	}

	def buildGradleFileTree = fileTree(dir: new File(modulesDir, "ee"), include: "**/build.gradle")

	buildGradleFileTree.each {
		buildGradleFile ->

		def buildGradle = buildGradleFile.text

		projectDepsReplacements.each {
			k, v ->

			buildGradle = buildGradle.replace(k, v)
		}

		buildGradleFile.text = buildGradle
	}
}

wrapper {
	gradleVersion = "2.11"
}

writeDependencyVersions << {
	assert project.properties["depName"] : "Please provide -PdepName"

	Map dependenciesMap = [:] as TreeMap

	def buildGradleFiles = fileTree(dir: modulesDir, include: "**/build.gradle")

	def pattern = ~(', name: "' + Pattern.quote(depName) + '", version: "(.+)"')

	buildGradleFiles.each {
		def matcher = it.text =~ pattern

		if (matcher.find()) {
			def depVersion = matcher.group(1)

			def fileNames = dependenciesMap[depVersion]

			if (!fileNames) {
				fileNames = new TreeSet<String>()

				dependenciesMap[depVersion] = fileNames
			}

			fileNames << it
		}
	}

	dependenciesMap.each {
		k, v ->

		println "${k} = ${v}"
	}
}

writeGradleTestsScript << {
	def testProperties = GUtil.loadProperties(new File(portalDir, "test.properties"))

	def pluginExclude = testProperties.getProperty("gradle.plugins.test.excludes")

	def pluginExcludes = pluginExclude.split(",")

	pluginExcludes = pluginExcludes.collect {
		"${it}/"
	}

	def buildGradleFiles = fileTree(dir: new File(modulesDir, "sdk"), excludes: pluginExcludes, include: "**/build.gradle")

	def dirPath = portalDir.toPath()

	def gradlewPath = dirPath.resolve("gradlew")

	buildGradleFiles.each {
		buildGradleFile ->

		if (!buildGradleFile.text.contains("org.ysb33r.gradletest")) {
			return
		}

		def moduleDirPath = buildGradleFile.parentFile.toPath()

		def relativePath = dirPath.relativize(moduleDirPath).toString()

		dirPath = moduleDirPath

		relativePath = relativePath.replace(File.separatorChar, '/' as char)

		println "cd ${relativePath}"

		relativePath = dirPath.relativize(gradlewPath).toString()

		relativePath = relativePath.replace(File.separatorChar, '/' as char)

		println "${relativePath} gradleTest"
	}
}

writeSettingsIncludes << {
	def settingsIncludes = []

	def xmlParser = new XmlParser()

	xmlParser.setFeature "http://apache.org/xml/features/disallow-doctype-decl", false

	def buildXmlFile = new File(modulesDir, "build.xml")

	def projectNode = xmlParser.parse(buildXmlFile)

	projectNode.path.dirset.each {
		def node ->

		def dir = node.attribute("dir")
		def excludes = node.attribute("excludes") ?: ""
		def includes = node.attribute("includes") ?: ""

		def dirNames = excludes.tokenize(",")

		dirNames.each {
			def dirName ->

			settingsIncludes << "exclude \"${dir}/${dirName}/build.gradle\""
		}

		dirNames = includes.tokenize(",")

		dirNames.each {
			def dirName ->

			settingsIncludes << "include \"${dir}/${dirName}/build.gradle\""
		}
	}

	settingsIncludes.sort()

	def settingsIncludesFile = file("tmp/settings-includes.gradle")

	settingsIncludesFile.parentFile.mkdirs()

	settingsIncludesFile.withWriter {
		def writer ->

		def previousTitle

		settingsIncludes.each {
			def title = it.substring(0, it.indexOf(' '))

			if (previousTitle && (previousTitle != title)) {
				writer.writeLine
			}

			writer.write "\t\t"
			writer.writeLine it
		}
	}
}

private void _copyLibToCache(Project project, File gradleCacheDir, String libGroup, String libName, String libVersion, String libClassifier) {
	if (!libGroup || !libName || !libVersion) {
		throw new GradleException("libGroup, libName, and libVersion are required")
	}

	String mavenLibGroup = libGroup.replace('.', '/')

	File gradleLibDir = new File(gradleCacheDir, "${libGroup}/${libName}/${libVersion}")
	File mavenLibDir = new File(System.getProperty("user.home"), ".m2/repository/${mavenLibGroup}/${libName}/${libVersion}")

	["jar", "pom"].each {
		String extension ->

		String sourceFileName = "${libName}-${libVersion}"

		if (libClassifier) {
			if (extension != "jar") {
				return
			}

			sourceFileName += "-${libClassifier}"
		}

		sourceFileName += ".${extension}"

		File sourceFile = new File(mavenLibDir, sourceFileName)

		if (!sourceFile.exists()) {
			String sourceUrl = "https://repository.liferay.com/nexus/content/groups/public/${mavenLibGroup}/${libName}/${libVersion}/${sourceFileName}"

			try {
				project.download {
					dest buildDir
					src sourceUrl
				}
			}
			catch (Exception e) {
				println e

				return
			}

			sourceFile = new File(buildDir, sourceFileName)
		}

		String sha1 = _getSHA1(sourceFile)

		project.copy {
			from sourceFile
			into new File(gradleLibDir, sha1)
		}
	}
}

private File _getModuleDir(String dirName) {
	def moduleDir

	modulesDir.traverse(
		preDir: {
			if (it.name == dirName) {
				moduleDir = it

				return FileVisitResult.TERMINATE
			}
		},
		type: FileType.DIRECTORIES
	)

	return moduleDir
}

private String _getSHA1(File file) {
	file.withInputStream {
		String sha1 = DigestUtils.sha1Hex(it)

		StringUtils.stripStart(sha1, "0")
	}
}